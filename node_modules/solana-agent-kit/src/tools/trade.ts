import { SolanaAgentKit } from 'solana-agent-kit';
import { PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { Trade, Token, Order } from './types';
import { TokenManager } from './tokenManager';
import { MarketSimulator } from './marketSimulator';
import { AtomManager } from '../agents/atomManager';
import { v4 as uuidv4 } from 'uuid';
import * as fs from 'fs';
import * as path from 'path';
import { env } from '../utils/environment';

export class TradingSystem {
  private solanaAgent: SolanaAgentKit;
  private tokenManager: TokenManager;
  private marketSimulator: MarketSimulator;
  private atomManager: AtomManager;
  private trades: Trade[] = [];
  private orders: Order[] = [];
  private basePath: string;

  constructor(
    tokenManager: TokenManager,
    marketSimulator: MarketSimulator,
    atomManager: AtomManager
  ) {
    // Create a separate agent instance if needed; alternatively, you could re-use the one from tokenManager.
    this.solanaAgent = new SolanaAgentKit(
      env.SOLANA_PRIVATE_KEY,
      env.RPC_URL,
      env.OPENAI_API_KEY
    );

    this.tokenManager = tokenManager;
    this.marketSimulator = marketSimulator;
    this.atomManager = atomManager;
    
    this.basePath = path.join(process.cwd(), 'data', 'trading');
    if (!fs.existsSync(this.basePath)) {
      fs.mkdirSync(this.basePath, { recursive: true });
      fs.mkdirSync(path.join(this.basePath, 'trades'), { recursive: true });
      fs.mkdirSync(path.join(this.basePath, 'orders'), { recursive: true });
    }
  }

  async executeTrade(
    atomId: string,
    tokenSymbol: string,
    type: 'buy' | 'sell',
    amount: number,
    maxSlippage: number = 0.01 // 1% max slippage
  ): Promise<Trade> {
    const atom = this.atomManager.getAtom(atomId);
    if (!atom) {
      throw new Error(`Atom with ID ${atomId} not found`);
    }
    
    const token = this.tokenManager.getToken(tokenSymbol);
    if (!token) {
      throw new Error(`Token with symbol ${tokenSymbol} not found`);
    }
    
    // Get current price from the market simulator (assumed in USDC per token)
    const currentPrice = this.marketSimulator.getTokenPrice(tokenSymbol);
    
    // Generate a unique ID for the trade
    const tradeId = uuidv4();
    
    // Create trade object (store extra details for simulation records)
    const trade: Trade = {
      id: tradeId,
      atomId,
      walletAddress: atom.walletAddress,
      tokenSymbol,
      tokenAddress: token.mintAddress,
      type,
      amount,
      price: currentPrice,
      transactionSignature: '',
      timestamp: Date.now(),
      success: false
    };
    
    try {
      console.log(`Executing ${type} trade for ${amount} ${tokenSymbol} at $${currentPrice.toFixed(4)} by atom ${atomId}`);
      
      // Convert the token mint addresses into PublicKey objects.
      const targetTokenPubKey = new PublicKey(token.mintAddress);
      const usdcToken = this.tokenManager.getToken('USDC');
      if (!usdcToken) {
        throw new Error('USDC token not found for trading');
      }
      const usdcPubKey = new PublicKey(usdcToken.mintAddress);
      
      let signature: string;
      
      if (type === 'buy') {
        // For a buy trade, you pay with USDC to receive the target token.
        // Calculate the USDC amount to spend: (desired target token quantity) Ã— (current price)
        const usdcAmount = amount * currentPrice;
        // Call agent.trade:
        //   - outputMint: target token's mint (token you want to receive)
        //   - inputAmount: USDC amount (in token units; trade.ts multiplies by LAMPORTS_PER_SOL)
        //   - inputMint: USDC token's mint (token you pay with)
        //   - slippageBps: maxSlippage in basis points.
        signature = await this.solanaAgent.trade(
          targetTokenPubKey,
          usdcAmount,
          usdcPubKey,
          maxSlippage * 100
        );
      } else {
        // For a sell trade, you sell the target token for USDC.
        // Here, input is the target token and output is USDC.
        // Use the 'amount' as the number of target tokens to sell.
        signature = await this.solanaAgent.trade(
          usdcPubKey,
          amount,
          targetTokenPubKey,
          maxSlippage * 100
        );
      }
      
      trade.transactionSignature = signature;
      trade.success = true;
      
      this.trades.push(trade);
      this.saveTrade(trade);
      
      // Apply market impact simulation.
      this.simul

