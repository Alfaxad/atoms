"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSolanaTools = exports.SolanaCreateImageTool = exports.SolanaPumpfunTokenLaunchTool = exports.SolanaGetWalletAddressTool = exports.SolanaRegisterDomainTool = exports.SolanaRequestFundsTool = exports.SolanaTradeTool = exports.SolanaMintNFTTool = exports.SolanaDeployCollectionTool = exports.SolanaDeployTokenTool = exports.SolanaTransferTool = exports.SolanaBalanceTool = void 0;
const tools_1 = require("langchain/tools");
const web3_js_1 = require("@solana/web3.js");
const toJSON_1 = require("../utils/toJSON");
const create_image_1 = require("../tools/create_image");
class SolanaBalanceTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_balance";
        this.description = "Get the balance of a Solana wallet or token account. Input can be a token address or empty for SOL balance.";
    }
    async _call(input) {
        try {
            const tokenAddress = input ? new web3_js_1.PublicKey(input) : undefined;
            const balance = await this.solanaKit.getBalance(tokenAddress);
            return `Balance: ${balance}`;
        }
        catch (error) {
            return `Error getting balance: ${error.message}`;
        }
    }
}
exports.SolanaBalanceTool = SolanaBalanceTool;
class SolanaTransferTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_transfer";
        this.description = "Transfer tokens or SOL to another address. Input should be JSON string with: {to: string, amount: number, mint?: string}";
    }
    async _call(input) {
        try {
            const { to, amount, mint } = JSON.parse(input);
            const recipient = new web3_js_1.PublicKey(to);
            const mintAddress = mint ? new web3_js_1.PublicKey(mint) : undefined;
            await this.solanaKit.transfer(recipient, amount, mintAddress);
            return `Successfully transferred ${amount} to ${to}`;
        }
        catch (error) {
            return `Error making transfer: ${error.message}`;
        }
    }
}
exports.SolanaTransferTool = SolanaTransferTool;
class SolanaDeployTokenTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_deploy_token";
        this.description = "Deploy a new SPL token. Input should be JSON string with: {decimals?: number, initialSupply?: number}";
    }
    async _call(input) {
        try {
            const validJson = input
                .replace(/([a-zA-Z0-9_]+):/g, '"$1":') // Add quotes around keys
                .trim();
            const { decimals = 9 } = JSON.parse(validJson);
            const result = await this.solanaKit.deployToken(decimals);
            return `Token deployed successfully. Mint address: ${result.mint.toString()}`;
        }
        catch (error) {
            return `Error deploying token: ${error.message}`;
        }
    }
}
exports.SolanaDeployTokenTool = SolanaDeployTokenTool;
class SolanaDeployCollectionTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_deploy_collection";
        this.description = "Deploy a new NFT collection. Input should be JSON with: {name: string, uri: string, royaltyBasisPoints?: number, creators?: Array<{address: string, percentage: number}>}";
    }
    async _call(input) {
        try {
            const options = JSON.parse(input);
            const result = await this.solanaKit.deployCollection(options);
            return `Collection deployed successfully. Address: ${result.collectionAddress.toString()}`;
        }
        catch (error) {
            return `Error deploying collection: ${error.message}`;
        }
    }
}
exports.SolanaDeployCollectionTool = SolanaDeployCollectionTool;
class SolanaMintNFTTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_mint_nft";
        this.description = "Mint a new NFT in a collection. Input should be JSON with: {collectionMint: string, metadata: {name: string, symbol: string, uri: string}, recipient?: string}";
    }
    async _call(input) {
        try {
            const { collectionMint, metadata, recipient } = JSON.parse(input);
            const recipientPubkey = recipient ? new web3_js_1.PublicKey(recipient) : undefined;
            const result = await this.solanaKit.mintNFT(new web3_js_1.PublicKey(collectionMint), metadata, recipientPubkey);
            return `NFT minted successfully. Mint address: ${result.mint.toString()}`;
        }
        catch (error) {
            return `Error minting NFT: ${error.message}`;
        }
    }
}
exports.SolanaMintNFTTool = SolanaMintNFTTool;
class SolanaTradeTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_trade";
        this.description = "Swap tokens using Jupiter Exchange. Input should be JSON with: {outputMint: string, inputAmount: number, inputMint?: string, slippageBps?: number}";
    }
    async _call(input) {
        try {
            const { outputMint, inputAmount, inputMint, slippageBps } = JSON.parse(input);
            const tx = await this.solanaKit.trade(new web3_js_1.PublicKey(outputMint), inputAmount, inputMint ? new web3_js_1.PublicKey(inputMint) : undefined, slippageBps);
            return `Trade executed successfully. Transaction: ${tx}`;
        }
        catch (error) {
            return `Error executing trade: ${error.message}`;
        }
    }
}
exports.SolanaTradeTool = SolanaTradeTool;
class SolanaRequestFundsTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_request_funds";
        this.description = "Request SOL from Solana faucet (devnet/testnet only)";
    }
    async _call(_input) {
        try {
            await this.solanaKit.requestFaucetFunds();
            return "Successfully requested faucet funds";
        }
        catch (error) {
            return `Error requesting funds: ${error.message}`;
        }
    }
}
exports.SolanaRequestFundsTool = SolanaRequestFundsTool;
class SolanaRegisterDomainTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_register_domain";
        this.description = "Register a .sol domain name. Input should be JSON with: {name: string, spaceKB?: number}";
    }
    async _call(input) {
        try {
            const { name, spaceKB = 1 } = JSON.parse(input);
            const tx = await this.solanaKit.registerDomain(name, spaceKB);
            return `Domain registered successfully. Transaction: ${tx}`;
        }
        catch (error) {
            return `Error registering domain: ${error.message}`;
        }
    }
}
exports.SolanaRegisterDomainTool = SolanaRegisterDomainTool;
class SolanaGetWalletAddressTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_get_wallet_address";
        this.description = "Get the wallet address of the agent";
    }
    async _call(_input) {
        return this.solanaKit.wallet_address.toString();
    }
}
exports.SolanaGetWalletAddressTool = SolanaGetWalletAddressTool;
class SolanaPumpfunTokenLaunchTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_launch_pumpfun_token";
        this.description = "Launch a new token on Pump.fun via Solana Agent Kit. Requires a JSON input with tokenName, tokenTicker, description, imageUrl, and optional fields for twitter, telegram, website, and initialLiquiditySOL.";
    }
    validateInput(input) {
        if (!input.tokenName || typeof input.tokenName !== "string") {
            throw new Error("tokenName is required and must be a string");
        }
        if (!input.tokenTicker || typeof input.tokenTicker !== "string") {
            throw new Error("tokenTicker is required and must be a string");
        }
        if (!input.description || typeof input.description !== "string") {
            throw new Error("description is required and must be a string");
        }
        if (!input.imageUrl || typeof input.imageUrl !== "string") {
            throw new Error("imageUrl is required and must be a string");
        }
        if (input.initialLiquiditySOL !== undefined &&
            typeof input.initialLiquiditySOL !== "number") {
            throw new Error("initialLiquiditySOL must be a number when provided");
        }
    }
    async _call(input) {
        try {
            // Parse and normalize input
            const parsedInput = (0, toJSON_1.toJSON)(input);
            // Validate the input
            this.validateInput(parsedInput);
            // Launch token with validated input
            await this.solanaKit.launchPumpFunToken(parsedInput.tokenName, parsedInput.tokenTicker, parsedInput.description, parsedInput.imageUrl, {
                twitter: parsedInput.twitter,
                telegram: parsedInput.telegram,
                website: parsedInput.website,
                initialLiquiditySOL: parsedInput.initialLiquiditySOL,
            });
            return JSON.stringify({
                status: "success",
                message: "Token launched successfully on Pump.fun",
                tokenName: parsedInput.tokenName,
                tokenTicker: parsedInput.tokenTicker,
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.SolanaPumpfunTokenLaunchTool = SolanaPumpfunTokenLaunchTool;
class SolanaCreateImageTool extends tools_1.Tool {
    constructor(solanaKit) {
        super();
        this.solanaKit = solanaKit;
        this.name = "solana_create_image";
        this.description = "Create an image using OpenAI's DALL-E";
    }
    async _call(input) {
        try {
            const result = await (0, create_image_1.create_image)(this.solanaKit, input);
            return JSON.stringify(result);
        }
        catch (error) {
            return `Error creating image: ${error.message}`;
        }
    }
}
exports.SolanaCreateImageTool = SolanaCreateImageTool;
function createSolanaTools(solanaKit) {
    return [
        new SolanaBalanceTool(solanaKit),
        new SolanaTransferTool(solanaKit),
        new SolanaDeployTokenTool(solanaKit),
        new SolanaDeployCollectionTool(solanaKit),
        new SolanaMintNFTTool(solanaKit),
        new SolanaTradeTool(solanaKit),
        new SolanaRequestFundsTool(solanaKit),
        new SolanaRegisterDomainTool(solanaKit),
        new SolanaGetWalletAddressTool(solanaKit),
        new SolanaPumpfunTokenLaunchTool(solanaKit),
        new SolanaCreateImageTool(solanaKit),
    ];
}
exports.createSolanaTools = createSolanaTools;
//# sourceMappingURL=index.js.map